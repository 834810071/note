[Unix环境高级编程](https://github.com/834810071/note/blob/master/APUE/README.md)
=================================
# 第一章 UNIX基础知识
## 1.2 登录
### 1.2.1 登录名
>> 口令文件: /etc/passwd文件中查看登录名。分别是登录名，加密口令，数字用户ID(224)，数字组ID(20)，注释字段，起始目录(/home/stevens)，以及shell程序(/bin/ksh)。

### 1.2.2 shell
>> shell是一个命令行解释器。系统从口令文件中登录项的最后一个字段中了解到应该执行哪一个shell。

## 1.3 文件和目录
### 1.3.1 文件系统
>> 目录是一个包含目录项的文件。文件的属性：文件类型、文件长度、文件所有者，文件许可权，文件的最后修改时间等。    
 
>> stat函数返回一个包含所有文件属性的信息结构。

### 1.3.2 文件名
>> 当创建一个新目录时，自动创建了两个文件名： . 和 ..

### 1.3.3 路径名

## 1.4 输入和输出
### 1.4.1 文件描述符
>> 文件描述符是一个小的非负整数，内核用以标识一个特定进程正在访存的文件。

### 1.4.2 [标准输入、标准输出和标准出错](https://www.jianshu.com/p/bce6810b7c27)

### 1.4.3 [不用缓存的I/O](https://blog.51cto.com/4983206/1142074)
>>函数open、read、write、lseek以及close提供了不用缓存的I/O。

## 1.5 程序和进程
### 1.5.1 程序
>> 程序是存放在磁盘文件中的可执行文件。使用6个exec函数中的一个由内核将程序读入存储器，并使其执行。

### 1.5.2 进程和进程ID
>> 程序的执行实例被称为进程。

## 1.6 ANSI C
### 1.6.2 类属指针
>> ANSI C使用void* 作为类属指针来代替char*。

## 1.10 UNIX时间值
>> UNIX系统的两种不同时间值：   
>> (1) 日历时间。    
>> (2) 进程时间。也称为CPU时间，用以度量进程使用的中央处理机资源。  

>> 当度量一个进程的执行时间时，UNIX系统使用三个进程时间值：
>> * 时钟时间   进程运行的时间总量
>> * 用户CPU时间
>> * 系统CPU时间

>> 用户CPU时间是执行用户指令所用的时间量。系统CPU时间是为该进程执行内核所经历的时间。  用户CPU时间和系统CPU时间总和就是CPU时间。

## 1.11 系统调用和库函数

第2章 UNIX标准化及实现没看

# 第3章 文件I/O
>> 不带缓存指的是每个read和write都调用内核中的一个系统调用。

## 3.10 文件共享
>>(1) 每个进程在进程表中都有一个记录项，每个记录项中有一张打开的文件描述符表，可将其视为一个矢量，每个文件描述符占一项。与每个文件描述符相关联的是：   (a) 文件描述符标志。    (b) 指向一个文件表项的指针。  
>>(2) 内核为所有打开文件维持一张文件表。每个文件表项包含：  (a)文件状态标志(读、写、增写、同步、非阻塞等)。   (b) 当前文件位移量。   (c) 指向该文件v节点表项指针。     
>>(3) 每个打开文件都有一个v节点结构。  i节点：索引节点，包含文件所有者，文件长度，文件所在的设备，指向文件在盘上所使用的实际数据块指针等等。

![打开文件的内核数据结构](https://github.com/834810071/note/blob/master/APUE/12535952-0ea98ec2dbc1ef7e.png "打开文件的内核数据结构")

>> 可能有多个文件描述符指向同一文件表项。

>> 文件描述符标志和文件状态标志，前者只用于一个进程的一个描述符，后者适用于指向该给定文件表项的任何进程中的所有描述符。    

## 3.11 原子操作

## 3.13 fcntl函数
>>fcntl函数可以改变已经打开文件的性质。  
>>fcntl函数有五种功能：   
>> * 复制一个现存的描述符（cmd = F_DUPFD）。   
>> * 获得/设置文件描述符标记（cmd = F_GETFD或F_SETFD）。
>> * 获得/设置文件状态标记（cmd = F_GETFL或F_SETFL）。
>> * 获得/设置异步I/O有权(cmd = F_GETOWN或F_SETOWN)。
>> * 获得/设置记录锁(cmd = F_GETTLK,F_SETTLK或F_SETLKW)。

# 第4章 文件和目录
## 4.2 stat、fstat和lstat函数
## 4.3 文件类型
>> (1) 普通文件 (2) 目录文件 (3) 字符特殊文件 (4) 块特殊文件 (5) FIFO。用于进程间通信，也称为命名管道 (6) 套接口 (7) 符号连接

## 4.14 文件系统
>> 一个磁盘分为一个或多个分区，每个分区可以包含一个文件系统。

![磁盘、分区和文件系统](https://github.com/834810071/note/blob/master/APUE/20160306092105166.jpeg "磁盘、分区和文件系统")

>> i节点是固定长度的记录项，它包含有关文件的信息。

![较详细的文件系统](https://github.com/834810071/note/blob/master/APUE/20160306092135213.jpeg "较详细的文件系统")

## 4.16 符号连接
>> 硬链接限制： (a) 硬连接通常要求连接和文件位于同一文件系统中。 (b) 只有超级用户才能创建到目录的硬链接。  


# 第5章 标准I/O库
## 5.4 缓存
>> 标准I/O提供了三种类型的缓存:(1) 全缓存 (2) 行缓存 (3) 不带缓存

## 5.12 
>> 当标准输入、输出连至终端时，他们是航缓存的。长度是128字节。
>> 当将这两个文件定向到普通文件时，它们就变成全缓存，其缓存长度是该文件系统优先选用的I/O长度。

# 第7章 UNIX进程的环境
## 7.3 进程终止
>> 有五种方式使进程终止：
>> (1) 正常终止： (a) 从main返回。(b) 调用exit。 (c) 调用_exit。
>> (2) 异常终止： (a) 调用abort。 (b) 由一个信号终止。  

### 7.3.1 exit和_exit函数
>>_exit立即进入内核，exit则先执行一些清除处理（包括调用执行各终止处理程序，关闭所有标准I/O流等），然后进入内核。

### 7.3.2 [atexit函数](https://www.cnblogs.com/noble/p/4144166.html)
>> ANSI C规定，一个进程可以登记多至32个函数，这些函数将由exit自动调用。称这些函数为终止处理程序，并用atexit函数来登记这些函数。

![一个C程序是如何启动起来的](https://github.com/834810071/note/blob/master/APUE/20160205152227171.jpg "一个C程序是如何启动起来的")

>> 内核使程序执行的唯一方法是调用一个exec函数。进程自愿终止的唯一方法是显示或隐式地调用exit或_exit方法。

## 7.6 C程序的存储空间布局
>> C程序一直由以下几部分组成：  
>> * 正文段。这是由CPU执行的机器指令部分。
>> * 初始化数据的。
```cpp
int maxcount = 99;
```
>> * 非初始化数据段。
```cpp
long sum[1000];
```
>> * 栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。
>> * 堆。通常在堆中进行动态存储分配。

![典型的存储器安排](https://github.com/834810071/note/blob/master/APUE/20180113171442840.png "典型的存储器安排")

# 第8章 进程控制
>> ## 8.2 进程标识
>> 进程ID 0是调度进程，常常被称为交换进程(swapper)。进程 1通常是init进程，在自举过程结束时由内核调用。

>> 子进程获得父进程数据空间、堆和栈的复制品。

>> fork的一个特性是由所有父进程打开的描述符都被复制到子进程中。

## 8.4 vfork函数
>> vfork创建的子进程在父进程空间中运行。vfork保证了子进程先运行，在它调用exec或exit之后父进程才可能被调度执行。

>> 父进程在子进程之前终止：  它们的父进程都改变为init进程。称这些进程由init领养。     
>> 大致过程是：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止的进程的子进程，如果是，则该进程的父进程id就更改为1(init进程的ID)。   

>> 如果子进程在父进程之前终止，内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时，可以获得有关信息。   

>> 一个已经终止、但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息、释放它仍占用的资源）的进程被称为僵死进程。ps命令将僵死进程状态打印为Z。   

>> 一个由init进程领养的进程终止时会发生什么？它会不会变成僵死进程？  否，因为init被编写成只要有一个子进程终止，init就会用一个wait函数取得其终止状态。  

## 8.6 wait和waitpid函数
>> 当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。

>> wait与waitpid区别: 
>> * 在一个进程终止前，wait使其调用者阻塞，而waitpid有一选择项，可使调用者不阻塞。
>> * waitpid并不等待第一个终止的子进程__他有若干个选择项，可以控制它所等待的进程。

>> 对于wait唯一的出错是调用进程没有子进程。

>> 对于waitpid，如果指定的进程或进程组不存在，或者调用进程没有子进程都能出错.

>> waitpid提供了wait函数没有提供的三个功能：  
>> (1) waitpid等待一个特定的进程。  
>> (2) waitpid提供了一个wait的非阻塞版本。    
>> (3) waitpid支持作业控制[启动、停止、无条件终止以及恢复作业的这些功能统称为作业控制，通过作业控制，你就能完全控制shell中正在运行的所有作业。]。  

# 第9章 进程关系

### 9.2.1 4.3+BSD终端登录
>> 系统管理者创建一个通常名为/etc/ttys的文件，其中每个终端设备有一行，每一行说明设备名和传到getty程序的参数，这些参数说明了终端的波特率等。当系统自举时，内核创建进程ID 1，也就是init进程。init进程进入多用户状态。init读文件/etc/ttys，对每个允许登录的终端设备，init调用一次fork，它所生成子进程则执行getty。
  