# 3.1 线程基础

### 3.1 线程的基本概念

线程的英文单词是 **thread**，翻译成对应的中文有”分支“、”枝干“的意思，当然这里翻译成”线程“属于意译了。提高线程就不得不提与线程相关联的另外一个概念”**进程**“，一个”**进程**“代表中计算机中实际跑起来的一个程序，在现代操作系统的保护模式下，每个进程拥有自己独立的进程地址空间和上下文堆栈。但是就一个程序本身执行的操作来说，进程其实什么也不做（不执行任何进程代码），它只是提供一个大环境容器，在进程中实际的执行体是”**线程**“。**wiki** 百科上给线程的定义是：

```c
In computer science, a thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler, which is typically a part of the operating system.
计算机科学中，线程是操作系统管理的、可以执行编制好的最小单位的指令序列的调度器。
```

翻译的有点拗口，通俗地来说，线程是进程中实际执行代码的最小单元，它由操作系统安排调度（何时启动、何时运行和暂停以及何时消亡）。

进程与线程的区别与关系这里就不再多说了，任何一本关于操作系统的书籍都会有详细的介绍。这里需要重点强调的是如下几个问题，这也是我们在实际开发中使用多线程需要搞明白的问题。

#### 一个进程至少有一个线程

上文也说了，线程是进程中实际干活的单位，因此一个进程至少得有一个线程，我们把这个线程称之为”**主线程**“，也就是说，**一个进程至少要有一个主线程**。

#### 主线程退出，支线程也将退出吗？

在 **Windows** 系统中，当一个进程存在多个线程时，如果主线程执行结束了，那么这个时候即使支线程（也可以叫**工作线程**）还没完成相关的代码执行，支线程也会退出，也就是说，主线程一旦退出整个进程也就结束了。之所以强调这一点是，很多多线程编程的初学者经常犯在工作线程写了很多逻辑代码，但是没有注意到主线程已经提前退出，导致这些工作线程的代码来不及执行。解决这一问题的方案很多，核心就是让主线程不要退出，或者至少在工作线程完成工作之前主线程不要退出。常见的解决方案有主线程启动一个循环或者主线程等待工作线程退出后再退出（下文将会详细介绍）。

在 **Linux** 系统中，如果主线程退出，工作线程一般不会受到影响，还会继续运行下去，但是此时这个进程就会变成所谓的**僵尸进程**，这是一种不好的做法，实际开发中应该避免产生僵尸进程。

```c
### ps -ef 命令查看系统进程列表时，带有<defunct>字样的进程即僵尸进程
[root@localhost ~]# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         2     0  0 Jan18 ?        00:00:01 [kthreadd]
root         3     2  0 Jan18 ?        00:00:25 [ksoftirqd/0]
root         5     2  0 Jan18 ?        00:00:00 [kworker/0:0H]
root     60928     1  0 14:48 pts/1    00:00:00 [linuxtid] <defunct>
```

> Linux 版本众多，在某些 Linux 版本实现中，主线程退出也会导致支线程退出，这个行为就和 Windows 上一样了。读者在实际开发时应该以自己的机器测试结果为准。

#### 某个线程崩溃，会导致进程退出吗？

这是一个常见的面试题，还有一种问法是：**进程中某个线程崩溃，是否会对其他线程造成影响？**

一般来说，每个线程都是独立执行的单位，每个线程都有自己的上下文堆栈，一个线程的的崩溃不会对其他线程造成影响。但是通常情况下，一个线程崩溃会产生一个进程内的错误，例如在 Linux 操作系统中，可能会产生一个**Segment Fault** 错误，这个错误会产生一个信号，操作系统默认对这个信号的处理就是结束进程，整个进程都被销毁了，这样的话这个进程中存在的其他线程自然也就不存在了。