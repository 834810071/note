# 第四节 one thread one loop 思想

**one thread one loop**

基于上一节介绍的Reactor模式，我们引出one thread one loop思想，所谓one thread one loop，翻译成中文的意思就是一个线程对应一个循环，这里说的线程针对的是网络相关的线程，也就是说一个每个线程函数里面有一个循环流程，这些循环流程里面做的都是相同的事情。其基本步骤如下：

```c
//线程函数
void thread_func(void* thread_arg)
{
	//这里做一些需要的初始化工作

	while (线程退出标志)
	{
		//步骤一：利用select/poll/epoll等IO复用技术，分离读写事件

		//步骤二：处理读事件或写事件

		//步骤三：做一些其他的事情
	}


	//这里做一些需要的清理工具
}
```

关键部分就是这个while循环部分，步骤一利用IO复用技术分离socket读写事件这里不再介绍了，我已经介绍得足够多了。重点是步骤二，处理读事件和可写事件，需要注意的是，在linux操作系统下，除了socket对象以外，其他对象也可以挂到IO复用函数去（下面的章节中您很快就会看到）。这里我们暂时先讨论socket对象，以处理读事件为例，一般对于侦听socket，我们处理它的读事件一般是接收新连接“等”操作，注意这里的“等”我加了个引号，也就是说，我们不仅仅可以接收新连接，也可以多做一点事情，如将由accept函数新产生的客户端socket绑定到IO复用函数上去，创建代表连接的对象等等各种操作；对于普通的socket，在不考虑出错的情况下，我们可以调用recv或者read函数收取数据，甚至我们可以对收到的数据解包，并做一些业务逻辑的处理。举个例子，假设我们收到的数据经解包后发现是登陆请求包，我们可以接着验证这些登陆数据，并应答客户端。那么这里的处理读事件实际上就包括：收数据、解包、验证数据、应答客户端四个步骤。对于处理写事件，一般就是发送数据了。关于如何正确地收发数据，我们将在[下一节](http://47.97.181.98/zsxq/2019/09/22/第四节-one-thread-one-loop-思想/#_第三节_收数据与发数据的正确做法)系统地介绍。

步骤三，做一些其他的事情。其他的事情就具体问题具体对待了，如我们可以将上一步的解包或者验证数据放在这里。毕竟从程序的设计的结构来说，检测事件（步骤一）和收发数据这个属于网络通信层的工作，而解包和验证数据属于应用层的工作。一个良好的设计，这两个工作应该是分离的。当然，还可以做一些其他的事情，我们很快很介绍到。

Ø 线程的分工

根据上面介绍的线程函数中的循环结构，服务器端为了能流畅处理多个客户端连接，一般在某个线程A里面accept新的客户端连接并生成新连接的socket，然后将这些新连接的socket传递给另外开的数个工作线程B1、B2、B3、B4，这些工作线程处理这些新连接上的网络IO事件（即收发数据），同时，还处理系统中的另外一些事务。这里我们将线程A称为主线程，B1、B2、B3、B4等称为工作线程。工作线程的代码框架上文介绍过了，我们这里再次将其翻译成代码：

```c
while (!m_bQuitFlag)

{
  epoll_or_select_func();
  handle_io_events();
  handle_other_things();
}
```

在epoll_or_select_func()中通过select()或者poll/epoll()去检测socket 上的IO事件，若存在这些事件则下一步handle_io_events()来处理这些事件（收发数据），做完之后可能还要做一些系统其他的任务，即调用handle_other_things()。

这样做有三个好处：

\1. 线程A只需要处理新连接的到来即可，不用处理网络IO事件。由于网络IO事件处理一般相对比较慢，如果在线程A里面既处理新连接又处理网络IO，则可能由于线程忙于处理IO事件，而无法及时处理客户端的新连接请求，这是很不好的。

\2. 线程A接收的新连接，可以根据一定的负载均衡原则将新的socket分配给工作线程。常用的算法，比如round robin，即轮询机制，即，假设不考虑中途有连接断开的情况，一个新连接来了分配给B1，又来一个分配给B2，再来一个分配给B3，再来一个分配给B4。如此反复，也就是说线程A记录了各个工作线程上的socket fd数量，这样可以最大化地来平衡资源，避免一些工作线程“忙死”，另外一些工作线程“闲死”的现象。

\3. 即使工作线程不满载的情况下，也可以让工作线程做其他的事情。比如现在有四个工作线程，但只有三个连接。那么线程B4就可以在handle_other_thing()做一些其他事情。

下面讨论一个很重要的效率问题：

 在上述while循环里面，epoll_or_selec_func()中的epoll_wait/poll/select等函数一般设置了一个超时时间。如果设置超时时间为0，那么在没有任何网络IO时间和其他任务处理的情况下，这些工作线程实际上会空转，白白地浪费cpu时间片。如果设置的超时时间大于0，在没有网络IO时间的情况，epoll_wait/poll/select仍然要挂起指定时间才能返回，导致需要handle_other_thing()不能及时执行，影响其他任务不能及时处理，也就是说其他任务一旦产生，其处理起来具有一定的延时性。这样也不好。那如何解决该问题呢？

 其实我们想达到的效果是，如果没有网络IO时间和其他任务要处理，那么这些工作线程最好直接挂起而不是空转；如果有其他任务要处理，这些工作线程要立刻能处理这些任务而不是在epoll_wait/poll/selec挂起指定时间后才开始处理这些任务。

 我们采取如下方法来解决该问题，以linux为例，不管epoll_fd上有没有文件描述符fd，我们都给它绑定一个默认的fd，这个fd被称为wakeup fd（唤醒fd）。当我们需要处理其他任务的时候，向这个唤醒fd上随便写入1个字节的，这样这个fd立即就变成可读的了，epoll_wait()/poll()/select()函数立即被唤醒，并返回，接下来马上就能执行handle_other_thing()，其他任务得到处理。反之，没有其他任务也没有网络IO事件时，epoll_or_select_func()就挂在那里什么也不做。

 这个唤醒fd，在linux操作系统上可以通过以下几种方法实现：

\1. 管道pipe，创建一个管道，将管道的一端绑定到epoll_fd上。需要时，向管道的另一端写入一个字节，工作线程立即被唤醒。

```c
int pipe(int pipefd[2]);

int pipe2(int pipefd[2], int flags);
```

\2. linux 2.6新增的eventfd：

```c
int eventfd(unsigned int initval, int flags);
```

步骤也是一样，将生成的eventfd绑定到epoll_fd上。需要时，向这个eventfd上写入一个字节，工作线程立即被唤醒。

\3. 第三种方法最方便。即linux特有的socketpair，socketpair是一对相互连接的socket，相当于服务器端和客户端的两个端点，每一端都可以读写数据，向其中一端写入数据，就可以从另外一端读取数据。

```c
int socketpair(int domain, int type, int protocol, int sv[2]);
```

调用这个函数返回的两个socket句柄就是sv[0]，和sv[1]，在一个其中任何一个写入字节，在另外一个收取字节。

将收取的字节的socket绑定到epoll_fd上。需要时，向另外一个写入的socket上写入一个字节，工作线程立即被唤醒。

需要注意的是，和创建普通socket稍微不同的是，创建socketpair，其domain参数一定要设置成AFX_UNIX。

在windows操作系统上，select函数只支持检测socket这一种fd，所以windows上一般只能模仿方法3的思路，即手动创建两个socket，然后调用connect/accept让一个socket连接另外一个socket，相当于一个socket作为客户端连接socket，另外一个socket调用bind和listen作为侦听socket。然后将读取的那一端的socket绑定到select上去并检测其可读事件。这是在写跨两个平台代码时，需要注意的地方。（这段需要优化一下，最好给出代码）